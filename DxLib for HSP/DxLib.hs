;--------------------------------------------------
; HSP ヘルプ ソースファイル (hs 形式)
; hs ファイルの書式については、HS_BIBLE.txt を参照してください。

;--------------------------------------------------
; この hs ファイルのデフォルトのフィールド値を設定

%dll
DxLib

%ver
3.14

%date
2019/09/16

%author
山田巧

%url
https://dxlib.xsrv.jp/

%note
DxLib.asをインクルードすること。

%type
; タイプ を記入

%port
; 対応環境 を記入

%portinfo
; 移植のヒント を記入

%index
DxLib_Init
ライブラリの初期化

%prm
; パラメータリスト を記入
; パラメータ説明文 を記入

%inst
　ＤＸライブラリを使用可能な状態に初期化します。
ＤＸライブラリを使用するソフトウェアはまずこの関数を呼び出す必要があります。
　この関数を使ってもし-1（エラー）が返ってきた場合は直ちにソフトを終了しなければなりません。

statの戻り値
０：成功
−１：エラー発生

%sample
; サンプルスクリプト を記入

%href
DxLib_End

%group
使用必須関数

%index
DxLib_End
ライブラリ使用の終了関数

%prm
; パラメータリスト を記入
; パラメータ説明文 を記入

%inst
　ＤＸライブラリの使用を終了する関数です。
ＤＸライブラリを使用しているソフトはすべてソフトを終了させる前にこの関数を呼ぶ必要があります。
　同時に、ＤＸライブラリはソフトのウインドウの制御もしているので、この関数を呼び出した後はなるべくすぐにプログラムを終了させなければなりません。

statの戻り値
０：成功
−１：エラー発生

%sample
; サンプルスクリプト を記入

%href
DxLib_Init

%group
使用必須関数

%index
ChangeWindowMode
ウインドウモード・フルスクリーンモードの変更を行う

%prm
Flag
Flag (int) : ウインドウモードで起動するかのフラグ情報
	TRUE : ウインドモードで起動
	FALSE : フルスクリーンモードで起動（デフォルト）

%inst
　ソフトをウインドウモードで実行するか、フルスクリーンモードで実行するのかを変更します。 一般にはウインドウモードよりフルスクリーンで実行する方が動作条件は良くなるのですが、 ソフトのデバッグ作業をフルスクリーンで行うのはどうしても困難なので、 制作中のみウインドウモードで実行し、完成バージョンではフルスクリーン実行にする、 等の用途に使えます。
　もしソフト中でウインドウモードとフルスクリーンモードの変更が出来るようにする場合はフルスクリーンとウインドウモードとのカラービット数の違いに気を付ける必要があります。 特に２５６色モードで実行するソフトでの配布版での変更は望ましくありません。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
ウインドウモード・フルスクリーンモード変更用関数

%index
SetUserWindow
ＤＸライブラリで使用するウインドウのハンドルをセットする

%prm
hwnd
hwnd (int) : ウインドウのハンドル

%inst
　ＤＸライブラリで使用するウインドウのハンドルをセットします。( DxLib_Init を実行する以前でのみ有効 )
　とくに理由がない限りhwndを使用してください。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
隠し関数

%index
SetUserWindowMessageProcessDXLibFlag
メッセージループ処理をＤＸライブラリで行うかどうかを設定する

%prm
Flag
Flag (int) : メッセージループ処理設定のフラグ
	TRUE : ＤＸライブラリで行う( デフォルト )
	FALSE : ＤＸライブラリでは行わない

%inst
　SetUseWindow で設定したウインドウのメッセージループ処理をＤＸライブラリで行うかどうかを設定します。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
隠し関数

%index
SetUseFPUPreserveFlag
FPUの精度の設定をする

%prm
Flag
Flag (int) : 精度のフラグ
	TRUE : 使用する(精度が落ちない)
	FALSE : 使用しない(精度を落とす(デフォルト))

%inst
　FPUの精度を落とさない設定を使用するかどうかを設定するします。
　DxLib_Init を呼び出す前のみ有効

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
隠し関数

%index
SetDrawScreen
描画先グラフィック領域の指定

%prm
DrawScreen
DrawScreen (int) : 描画する対象となるグラフィック領域を指定します。
	DX_SCREEN_FRONT : 表の画面（表示されている画面）
	DX_SCREEN_BACK : 裏の画面（表示されていない画面）

%inst
　アニメーションする画像を表示するとして常に表示されている画面に対して描画処理を行うと、 画面へ描画しているところや、描画したものを消している最中の状態が見えてしまい結果として画面がちらついているように見えてしまいます。 （ 注 … グラフィックカードによってはちらつかない場合もありますが、一般的にはちらつきます ）
　そこで画面への描画中は見えないようにして、描画処理が終った後で見えるようにすれば画面のちらつきは消えるはずです。 それを実現するためにこの関数があります。
　デフォルトでは描画先は DX_SCREEN_FRONT （表の画面）となっていて描画処理中も見えてしまい画面はちらつきますが、 描画先を DX_SCREEN_BACK （裏の画面）を指定すると描画先が普段は見えない裏の画面に対して行われます。
　描画が終った後で次に示す関数『ScreenFlip』を呼び出せば、 裏画面の内容が表画面に反映され、裏画面に描画していた内容が実際に表示されます。
　この関数はその描画先をどちらの画面にするか、を指定するための関数です。

　その他、MakeScreen 関数で作成したグラフィックハンドルを引数に渡すと、 そのグラフィックハンドルを描画先とすることができます。
( グラフィックハンドルを描画先とすることができることの利点については MakeScreen 関数の解説を参照してください )

＜注意＞
　この関数を使用して描画対象を変更すると、SetDrawArea で設定した描画可能範囲と、 ３Ｄ描画で使用するカメラの設定（ SetCameraPositionAndTarget_UpVecY などの関数でパラメータを設定する )がリセットされます。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
その他画面操作系関数

%index
SetGraphMode
画面モードの変更

%prm
Sizex, SizeY, ColorBitNum
SizeX , SizeY (int) : 画面の解像度
ColorBitNum (int) : カラービット数

%inst
　画面の解像度や最大表示色数を変更します。

＜注意＞
　この関数を実行するとロードしたすべてのグラフィックハンドルと３Ｄモデルハンドル、 作成したフォントハンドルは自動的に削除され、SetDrawArea, SetDrawScreen, SetDrawMode, SetDrawBlendMode, SetDrawBright 等の描画に関係する設定を行う関数による設定も全て初期状態に戻りますので、 画面モード変更後 LoadGraph関数や CreateFontToHandle関数等で再度ハンドルを作成し直し、 描画可能領域、描画対象画面等の各種描画系の設定も再度行う必要があります。

　画面の解像度は画面を表現するのに使用されるドット（点）の数です。
　パソコンのモニターが対応している解像度としては主に

　　640×480　800×600　1024×768　1280×1024　1280×720　1920×1080

　があります。（ デフォルトは640×480です ）。
　画面の解像度を上げると画面を構成する点の数が増え表現力も高くなりますが、 そのぶん画面の記憶に必要なメモリ容量も増えますので注意してください。

　指定した解像度がモニターやグラフィックスデバイスが対応していない場合は SetFullScreenResolutionMode で設定できる解像度モードに沿ってモニターが対応している別の解像度に拡大されて表示されます。 ( 別の解像度に拡大する処理は処理負荷がそこそこ高いので、モニターが対応している解像度を使用することをお勧めします )

　カラービット数とは使用する画面の色の数です。
　ビットとは２進数の１桁の事で、１６ビットで６５５３６色（Trueカラー） ２４ビットで１６７７万色（フルカラー）表現できます。 ビット数が上がれば上がるほど表現できる色の数は増えますが、その分必要なデータ量も増えますので注意してください。

　このライブラリで指定できるカラービット数は１６ビットと３２ビットの二つになります。

　指定したカラービット数に対応する３Ｄ機能を持たないグラフィックスデバイスでは３Ｄ機能が使用不可になります。
　１６ビットはＤＸライブラリの標準色ビット数で、６５５３６色を使って画像を表現します。
　３２ビットは内部的には２４ビットを使って１６６７万色で画像を表現します。（ 残りの８ビットは使用されません ） このモードを選択するとグラフィックデータのサイズが１６bitモードに比べて２倍になります。

　戻り値は、変更が成功した場合は DX_CAHNGESCREEN_OK　が失敗して元の画面モードに戻された場合は DX_CHANGESCREEN_RETURN が失敗して元の画面にも戻せず、デフォルトの画面モード( 640x480 16bit color)に変更された場合は DX_CHANGESCREEN_DEFAULT が、 それすらも失敗した場合はソフトが自動終了します。

　なおこの関数を DxLib_Init 関数を使用する前に呼び出すことにより初期状態の画面モードを設定することが出来ます。
この場合は画面モードの変更は DxLib_Init が呼ばれた際に行われるので画面モードの変更が成功するかどうか分からず、 関数は必ず DX_CHANGESCREEN_OK を返します。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
その他画面操作系関数

%index
MV1LoadModel
モデルの読み込み

%prm
FileName
FileName (str) ：　ロードする３Ｄモデルファイルのパス文字列のアドレス

%inst
　３Ｄモデルファイルをメモリにロードします。
ＤＸライブラリで３Ｄモデルを扱うときに必ず使用する関数です。
　この関数が成功するとモデルハンドルというものが返ってきます。
これはメモリに読み込んだ３Ｄモデルファイルの識別番号で int 型の数値です。
　読み込んだモデルを扱う際にこの識別番号を使用することになりますので、 MV1LoadModel の戻り値は必ずなんらかの変数に格納しておく必要があります。

例　　DxChara.x をロードして、戻り値であるモデルハンドルを
　　int 型変数 MHandle に保存します

    MV1LoadModel "DxChara.x"

    MHandle = stat

読み込むことのできるモデルファイル形式は x, mqo, mv1, pmd( + vmd ), pmx( + vmd ) の４種類です。
( 但し、pmx は pmd 相当の機能だけを使用していた場合のみ正常に読み込める仮対応状態です )

　尚、形状情報とアニメーション(アニメーション)情報はファイルの内容通りに読み込めますが、 マテリアル情報は各ファイル形式それぞれで異なる表現をしているものを無理矢理ＤＸライブラリのマテリアル表現で扱おうとするため、 大抵の場合モデリングソフト上とは異なった見た目になってしまいます。
　なので、そのような場合はＤＸライブラリに合わせてモデルファイルのマテリアルを調整していただくか、 ＤＸライブラリの３Ｄツールでマテリアルを調整してからライブラリの専用形式である mv1 形式で保存して、そのファイルを使っていただくことになります。
　また、モデルファイルで使用されているテクスチャはモデルファイルの中には含まれませんので、 モデルファイルで指定されているフォルダにテクスチャファイルを格納しておく必要があります。


MMD( MikuMikuDance )のモデルファイル( pmd or pmx )とモーションファイル( vmd )について。

＜対応度について＞

　一応モーションの再生と取れに伴うＩＫ、物理演算に対応していますが、完全に本家 MikuMikuDance と同じというわけではありません。


＜読み込みについて＞

　MikuMikuDance ではトゥーン用のテクスチャ( toon01.bmp 等 )はモデルファイル( pmd or pmx )が存在するテクスチャとは別のフォルダにあっても問題なく読み込むことが出来ますが、 ＤＸライブラリではトゥーン用のテクスチャもモデルファイル( pmd or pmx )と同じフォルダに格納しておく必要があります。( トゥーン用のデフォルトテクスチャは MikuMikuDance の Dataフォルダの中にあります )

　また、ＤＸライブラリでは MMD のモデルファイル形式( pmd or pmx )とモーションファイル形式( vmd )の読み込みに対応していますが、 モーションファイル( vmd )はモデルファイル( pmd or pmx )を読み込む際に一緒に読み込まれるようになっています。
　ただ、MV1LoadModel にはモーションファイルのファイル名を渡す引数はありませんので、 次のようなルールでモデルファイル( pmd or pmx )用のモーションファイルを検索します。

　１．モデルファイル名に３桁の番号がついたモーションファイルがあるか検索して、あったら読み込む
　　　( 検索する番号は 000 から )

　　　　　例えば、Miku.pmd ( 若しくは Miku.pmx ) というファイル名を FileName として渡した場合は、
　　　　　最初に Miku000.vmd というモーションファイルが存在するか調べます。

　２．検索する番号を000から順に１づつ増やしていき、存在しないファイル名になるまで読み込む

　　　　　例えば、Miku000.vmd、Miku001.vmd、Miku002.vmd と数字の繋がった３つのモーションファイルが
　　　　　あった場合は３つとも読み込まれます。
　　　　　仮に Miku000.vmd, Miku001.vmd, Miku005.vmd のように、番号が途切れていたら、Miku000.vmd と
　　　　　Miku001.vmd の二つだけ読み込まれ、Miku005.vmd は読み込まれません。

　尚、読み込み時にＩＫ計算を行いますので、xファイルやmv1ファイルに比べて読み込み時間が非常に長くなっています。


＜ループ再生するモーションについて＞

　モーションの中には歩きや走りといったループさせて再生を行う用途のモーションがあると思います。

　そのようなモーションの vmd ファイルは、＜読み込みについて＞の解説にあったファイル名の付け方にある３桁のモーションの番号の最後に半角の L をつけてください。

例：Miku000.vmd 〜 Miku002.vmd の３つのファイルがあり、Miku000.vmd と Miku002.vmd が
　　ループ再生用途のモーションの場合

　Miku000.vmd　Miku001.vmd　Miku002.vmd

　　　　　　　　　↓

　Miku000L.vmd　Miku001.vmd　Miku002L.vmd


　L を付けることで関数 MV1SetLoadModelUsePhysicsMode の設定が「読み込み時に物理演算を行う」 DX_LOADMODEL_PHYSICS_LOADCALC となっている場合( デフォルトの設定は DX_LOADMODEL_PHYSICS_LOADCALC です )の物理演算がループ再生用途のモーション用にモーションの最初と最後のフレームが綺麗に繋がり自然なループ再生ができるように処理されます。
　逆にループ用途のモーションではないのに L を付けてしまうとモーションの最後の部分が変になってしまうので注意してください。
　また、L を付けても物理演算によって動く部分の動きが激しいときはやっぱりループ時に不自然な見え方になってしまいますので、 その際はリアルタイム物理演算の設定である DX_LOADMODEL_PHYSICS_REALTIME をお使いください。


＜モーションの再生について＞

　モーションの再生は他の形式と同じように MV1AttachAnim を使用します( AnimIndex は vmd についている番号を指定します )
　フレーム構造の違う他のモデルのモーションを使用する場合は MV1AttachAnim の NameCheck を TRUE にしてください。

statの戻り値
−１　　　　：　エラー発生
−１以外　：　モデルのハンドル

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
３Ｄモデル関係の関数

%index
MV1AttachAnim
アニメーションをアタッチする

%prm
MHandle, AnimIndex, AnimSrcMhandle, NameCheck
MHandle (int) ： アニメーションをアタッチするモデルのハンドル
AnimIndex (int) ： アタッチするアニメーション番号
AnimSrcMHandle (int) ： アタッチするアニメーションを持っているモデルのハンドル
　　　　　　　　　　　　　　　( -1 を渡すと MHandle と同じモデルハンドルが使用されます )
NameCheck (int) ： AnimSrcMHandle が -1 以外の場合にアタッチするアニメーションの
　　　　　　　　　　　　　　フレームの名前とアタッチされる側のモデルのフレームの名前が
　　　　　　　　　　　　　　一致していない場合アタッチしないかどうか
　　　　　　　　　　　　　　( TRUE：アタッチしない　FALSE：アタッチする )
　　　　　　　　　　　　　　この引数は AnimSrcMHandle が -1 の場合は無視されます

%inst
　MHandle のモデルハンドルが示すモデルにアニメーションをアタッチします。

　アニメーションとは主にモデル内のフレームに対する動きのデータで、 キャラクターモデルが歩いたり走ったりといった表現をする際に使用します。 ( アニメーションのデータ自体は予めアニメーションデータを作成できるソフトを使用して作成しておく必要があります )

　ＤＸライブラリではアニメーションを再生する際に、 最初に再生したいアニメーションを指定する作業「アニメーションのアタッチ」をする必要があります。

　アタッチ自体は簡単で、この関数でアタッチしたいアニメーションの番号を渡すだけです。

　そして、アニメーションのアタッチが無事完了すると戻り値としてアタッチ番号が返ってきます。
　これは「ハンドル」と呼べるほどのものではありませんが、 モデルハンドルなどと同様にアタッチしたアニメーションに関する操作はすべてこのアタッチ番号を使用して行いますので、 アタッチ番号もモデルハンドルなどと同じように何かの変数にとっておく必要があります。

　アニメーションはアタッチした時点でアタッチしたアニメーションのカウント０の状態がモデルに反映されます。
　そして、アニメーションの再生カウントを変更する際は MV1SetAttachAnimTime を使用します。
　ＤＸライブラリには自動的にカウンタを進める仕組みはありませんので、 「MV1PlayAnim」 や 「MV1StopAnim」 のような名称の関数は存在しません。
　なので、MV1SetAttachAnimTime にセットする再生時間を徐々に進めることでアニメーションを再生します。

　引数 AnimSrcMHandle は同じフレーム構造を持った MHandle とは別のモデルのモデルに含まれているアニメーションを MHandle のモデルで再生する際に使用します。 ( 同じアニメーションを使用する見た目の違うキャラクターモデルが複数ある場合などは、 アニメーションだけのファイルと見た目の違うフレーム構造が同じメッシュだけのファイルを別々に用意することで各キャラクターモデルのファイルにはアニメーションデータを含める必要がなくなるので、 アニメーションデータの容量分だけデータサイズを削減することができます )

　引数 NameCheck は AnimSrcMHandle を使用して別のモデルファイルに含まれるアニメーションをアタッチする場合に、 アニメーションデータ側のフレームの名前とモーションをアタッチするモデルデータ側のフレームの名前を比較して違った場合はアタッチしないという処理をするかどうかを指定する引数で、 TRUE を渡すと比較して、FALSE を渡すと比較しません。

　名前を比較しない場合はフレームの階層構造と各階層のフレームの数がモデル側とアニメーション側で完全に一致していないと正常にアニメーションを再生することができません。
　名前を比較する場合はフレームの階層構造と名前が一致していればモデル側にあってアニメーション側に無いフレームがあっても正常にアニメーションを再生することができます。 ( ただし、同じ階層に同名のフレームが複数ある場合は正常にアニメーションを再生することはできません )

　名前比較を行うかどうかはアタッチするモーションデータにあわせて判断してください。

statの戻り値
−１以外：アニメーションアタッチ番号
−１：エラー発生

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
アニメーション関数
%index
MV1SetAttachAnimTime
アタッチしているアニメーションの再生時間を設定する

%prm
MHandle, AttachIndex, Time
MHandle (int) ： モデルのハンドル
AttachIndex (int) ： 再生時間を設定するアニメーションのアタッチ番号
Time (float) ： 再生時間

%inst
　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの再生時間を設定します。

　ＤＸライブラリのアニメーション機能には自動的にアニメーションを再生する機能はありませんので、 この関数を使用してアニメーションの再生時間を設定します。

　アニメーションのキーが存在しない時間が指定された場合は、 指定された時間の前後にあるキーからの補間値がモデルに反映されます。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
アニメーション関数

%index
SetCameraNearFar
カメラの 手前クリップ距離と 奥クリップ距離を設定する

%prm
Near, Far
float Near ： 手前( Near )クリップ距離( 0.0f より大きく Farより小さな値 )
float Far ： 奥( Far )クリップ距離( Nearより大きな値 )

%inst
　３Ｄ空間に何かを描画する際に、カメラからどれだけ離れたところ( Near )から、 どこまで( Far )のものを描画するかを設定します。

　この関数の設定値はかなり重要で、Ｚバッファの精度にも関わってきますので使用する３Ｄ空間の範囲に合わせて適切な値を設定する必要があります。
　例えば人間モデル１つの大きさが 200.0f くらいで大体画面奥方向に 10000.0f くらいまで移動して、 背景は画面奥方向に 15000.0f くらいまで存在して、かつカメラから 100.0f より近くに来たら見えないようにしたい場合は
SetCameraNearFar( 100.0f, 15000.0f ) ;
　とします。

　人間モデル一つの大きさがもっと小さく、1.0f くらいで、背景モデルも画面奥方向に 150.0f くらいまで描画できればよい場合は
SetCameraNearFar( 1.0f, 150.0f ) ;
　とします。

　因みに、Ｚバッファの仕様の関係で Far の設定値も重要ですが Near の設定値はより重要で、 例えば「なるべくカメラに近くても描画したい」という考えから
SetCameraNearFar( 0.00001f, 15000.0f ) ;
　としてしまったりすると大変です、環境によってはカメラから 100.0f 以上離れると描画されなくなったりします。
　なので、Near の値は不都合が無い範囲でなるべく大きな値を、Far の値は描画したい最奥のモノのより少し大きな値を設定するようにしてください。

＜注意＞なお、この関数の設定はSetDrawScreen、SetGraphMode、ChangeWindowMode のいずれかを使用したときにリセットされます。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
カメラ関数

%index
ClearDrawScreen
画面に描かれたものを消去する

%prm
hwnd
hwnd : ウインドウのハンドル

%inst
　各種描画関数で描画したグラフィックをすべて消し画面を初期化します。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
その他画面操作系関数


%index
SetCameraPositionAndTarget_UpVecY
カメラの視点、注視点を設定する( 上方向はＹ軸から算出 )

%prm
PositionX, PositionY, PositionZ, TargetX, TargetY, TargetZ
float Position ： カメラの位置
float Target ： カメラの注視点( 見ている座標 )

%inst
　３Ｄソフトと言えば視点がグリグリ変わります、 この関数はその視点の位置と見ているものを指定する関数です。

　カメラの姿勢は、視点、注視点と、あとカメラの上方向があれば決まりますが、 この関数はカメラの上方向をＹ軸のプラス方向を基本的なカメラの上方向として姿勢を算出します。

　因みに、ＤＸライブラリでは初期状態では視点の位置が x = 320.0f, y = 240.0f, z = ( 画面のサイズによって変化 )、 注視点の位置は x = 320.0f, y = 240.0f, z = 1.0f、カメラの上方向は x = 0.0f, y = 1.0f, z = 0.0f、 つまり画面のＸＹ平面上の中心に居てＺ軸のプラス方向を見るようなカメラになっています。

　引数 Position と引数 Target は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
カメラ関数

%index
MV1SetPosition
モデルの座標をセットする

%prm
MHandle, PositionX, PositionY, PositionZ
int　　　　MHandle ： モデルのハンドル
VECTOR Position ： モデルにセットする座標

%inst
　MHandle のモデルハンドルが示すモデルの座標をセットします。

　グラフィックハンドルでは座標やスケールと言ったものは画像自体には保持せず DrawGraph や DrawExtendGraph などの描画関数を呼ぶ際に直接指定していましたが、 ３Ｄモデルは設定すべき情報が多く、項目の数に合わせて描画関数のバリエーションを増やしたらとんでもないことになってしまうので、 この MV1SetPosition などの関数で描画を行う前に予め座標や回転値を設定するようになっています。

　座標は VECTOR 型の構造体( float x, y, z をメンバ変数に持つ構造体 )が引数になっていて、 いちいち VECTOR 構造体を定義してメンバ変数に座標値を代入して、という手順を踏まなければならなくて面倒ですが、 x, y, z の値を引数で渡すと VECTOR 構造体を戻り値として返してくれる VGet 関数を使用すれば面倒ではなくなります。

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
モデル基本制御関数


%index
MV1DrawModel
モデルを描画する

%prm
MHandle
int MHandle ：　描画するモデルのハンドル

%inst
　MHandle のモデルハンドルが示すモデルを画面に描画します。
　用途はモデルを画面に表示したい場合など・・・

　因みに、Ｚバッファを使用した現状の３Ｄレンダリングでは半透明の描画物は視点から最も離れているものから順に描画しないと正常な見た目になりませんので、 もし描画するモデルの中に半透明の部分が含まれている場合は視点からの距離を考慮した上で MV1DrawFrame や MV1DrawMesh で描画する必要があります。 ( ＤＸライブラリ自体にＺソートの機能はありません )

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
モデル描画関数


%index
ScreenFlip
フリップ関数、画面の裏ページ（普段は表示されていない）を 表ページ（普段表示されている）に反映する

%prm
; パラメータリスト を記入

%inst
　裏ページの内容を表ページに反映します。
(裏ページ、表ページについては 『SetDrawScreen』関数の解説を参照してください)

注…この関数を使用した後の裏ページの内容は環境によって変わりますので、ScreenFlip 関数を使用した後は ClearDrawScreen 等を使用して裏ページを初期化して下さい

%sample
; サンプルスクリプト を記入

%href
; 関連項目 を記入

%group
その他画面操作系関数


