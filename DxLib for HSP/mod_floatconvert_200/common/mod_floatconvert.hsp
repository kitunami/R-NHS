/*==========================================================================*/
//--------------------------------------------------------------------------//
/*
    name:       mod_floatconvert.hsp
    category:   HSP 用拡張モジュール
    require:    HSP 3.0 以降

    author:     naznyark

    ver:        2.00
    date:       2008/06/12

    description:
    HSP 用の拡張モジュールです。
    float 型の値(単精度実数値、32bit)(のメモリイメージ)と double 型の値(倍精度実数値、64bit)の相互変換を可能にします。

    　HSP プログラムから HSP 外部のコンポーネントを使用する際に float 型の値をメンバに持つ構造体などが必要になる場合があります。
    HSP の基本機能には float 型引数を持つ外部命令・外部関数に double 型の値を変換して渡す機能はありますが float 型の値を直接操作する機能はありません。
    このモジュールによる拡張機能では float 型の値と double 型の値の相互変換を行なうことができるようになり、間接的に float 型の値の操作を行なうことができるようになります。
*/
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
/*
	実装メイン。
*/
//--------------------------------------------------------------------------//

#ifndef         __MOD_FLOATCONVERT__
#define global  __MOD_FLOATCONVERT__

//--------------------------------------------------------------------------//

#module m_floatcvt

//------------------------------------------------------------//

#defcfunc dtof double p1, local base_, local exp_, local frc_
	//
	base_ = p1
	exp_ = ( ( lpeek( base_, 4 ) >> 20 ) & 0x07FF ) - 1023	// 指数部

	if ( exp_ <= -151 ) {
			// 0、または、非正規化数、または、０方向への表現可能範囲外。
		return ( lpeek( base_, 4 ) & 0x80000000 )
	}

	dim frc_, 3
	frc_( 0 ) = ( ( lpeek( base_, 4 ) << 3 ) & 0x007FFFF8 ) | ( ( lpeek( base_, 0 ) >> 29 ) & 0x00000007 )
	frc_( 1 ) = ( lpeek( base_, 0 ) << 3 ) & 0xFFFFFFF8, 0x00000000

	if ( ( exp_ >= -150 ) && ( exp_ <= -127 ) ) {
			// 非正規化数で表現。
		frc_( 0 ) |= 0x00800000
		frc_( 2 ) = frc_( 1 ) << ( 158 + exp_ )
		frc_( 1 ) = ( frc_( 0 ) << ( 158 + exp_ ) ) | ( ( frc_( 1 ) >> ( -126 - exp_ ) ) & ( 0x7FFFFFFF >> ( -127 - exp_ ) ) )
		frc_( 0 ) = ( ( frc_( 0 ) >> ( -126 - exp_ ) ) & ( 0x7FFFFFFF >> ( -127 - exp_ ) ) )
		exp_ = -127
	}

	// 表現可能範囲に丸める。
	if ( frc_( 1 ) & 0x80000000 ) {
		if ( ( ( frc_( 0 ) & 0x00000001 ) != 0 ) || ( ( frc_( 1 ) & 0x7FFFFFFF ) != 0 ) || ( ( frc_( 2 ) & 0xFFFFFFFF ) != 0 ) ) {
			frc_( 0 )++
			if ( frc_( 0 ) & 0x00800000 ) {
				frc_( 0 ) = 0x00000000
				exp_++
			}
		}
	}

	if ( exp_ == 1024 ) {
			// 無限大、または、NaN。
		return ( lpeek( base_, 4 ) & 0x80000000 ) | ( 0x7F800000 ) | ( frc_( 0 ) & 0x007FFFFF )
	}

	if ( exp_ >= 128 ) {
			// 無限大方向への表現可能範囲外。
		return ( lpeek( base_, 4 ) & 0x80000000 ) | ( 0x7F800000 )
	}

	return ( lpeek( base_, 4 ) & 0x80000000 ) | ( ( ( exp_ + 127 ) << 23 ) & 0x7F800000 ) | ( frc_( 0 ) & 0x007FFFFF )

//------------------------------------------------------------//

#defcfunc ftod int p1, local ret_
	//
	ret_ = 0.0

	if ( ( p1 & 0x7F800000 ) == 0x7F800000 ) {
			// 無限大、または、NaN。
		lpoke ret_, 4, ( p1 & 0x80000000 ) | ( 0x7FF00000 ) | ( ( p1 >> 3 ) & 0x000FFFFF )
		lpoke ret_, 0, ( p1 << 29 ) & 0xE0000000

	} else : if ( ( p1 & 0x7F800000 ) == 0x00000000 ) {

		if ( ( p1 & 0x007FFFFF ) == 0x00000000 ) {
				// 0。
			lpoke ret_, 4, p1 & 0x80000000

		} else {
				// 非正規化数。
			repeat 23
				if ( ( ( p1 << 9 << cnt ) & 0x80000000 ) != 0 ) {
					lpoke ret_, 4, ( p1 & 0x80000000 ) | ( ( ( ( ( p1 >> 23 ) & 0xFF ) - 127 + 1023 - cnt ) << 20 ) & 0x7FF00000 ) | ( ( p1 << cnt >> 2 ) & 0x000FFFFF )
					lpoke ret_, 0, ( p1 << cnt << 30 ) & 0xE0000000
					break
				}
			loop
		}

	} else {
		lpoke ret_, 4, ( p1 & 0x80000000 ) | ( ( ( ( ( p1 >> 23 ) & 0xFF ) - 127 + 1023 ) << 20 ) & 0x7FF00000 ) | ( ( p1 >> 3 ) & 0x000FFFFF )
		lpoke ret_, 0, ( p1 << 29 ) & 0xE0000000
	}

	return ret_

//------------------------------------------------------------//

#global

//--------------------------------------------------------------------------//

#endif

//--------------------------------------------------------------------------//
/*==========================================================================*/
